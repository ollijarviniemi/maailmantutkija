<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Play Level - Bayesian Factory</title>
    <link rel="stylesheet" href="css/style.css">
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #ffffff;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
            overflow: hidden;
        }
        .game-container {
            display: flex;
            flex-direction: row;
            height: 100vh;
            width: 100vw;
        }
        .left-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-width: 0;
        }
        .canvas-area {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 30px;
            overflow: visible;
            position: relative;
        }
        .right-panel {
            width: 280px;
            background: #f8f8f8;
            border-left: 2px solid #000;
            padding: 20px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        .panel-section {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .hypothesis-sacks {
            display: flex;
            flex-direction: row;
            gap: 12px;
            align-items: center;
            justify-content: center;
        }
        .sack-canvas {
            display: block;
        }
        .speed-controls {
            display: flex;
            gap: 8px;
        }
        .speed-btn {
            flex: 1;
            padding: 8px;
            background: #fff;
            border: 2px solid #ddd;
            font-size: 13px;
            cursor: pointer;
            font-family: inherit;
        }
        .speed-btn.active {
            background: #000;
            color: #fff;
            border-color: #000;
        }
        .speed-btn:hover:not(.active) {
            background: #f0f0f0;
        }
        .status-text {
            font-size: 16px;
            font-weight: 500;
            color: #666;
            text-align: center;
            padding: 12px;
        }
        .ball-count {
            font-size: 18px;
            font-weight: 500;
            color: #333;
            text-align: center;
        }
        .loss-display {
            font-size: 15px;
            font-weight: 500;
            color: #333;
            text-align: center;
            padding: 10px;
            background: #fff;
            border: 2px solid #000;
            border-radius: 2px;
            display: none;
        }
        .takaisin-btn {
            padding: 8px 16px;
            background: #fff;
            border: 2px solid #000;
            font-size: 13px;
            cursor: pointer;
            font-family: inherit;
            width: 100%;
            height: 40px;
            flex: 0 0 auto;
        }
        .takaisin-btn:hover {
            background: #f0f0f0;
        }
        #factory-canvas {
            border: 2px solid #ddd;
            display: block;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        #animation-overlay {
            position: absolute;
            background: rgba(255, 255, 255, 0.50);
            border: 1px solid #ddd;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 100;
            display: none;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
        }
        #animation-canvas {
            display: block;
        }
        .betting-panel {
            display: none; /* Hidden - betting interface now in right panel */
        }
        #betting-container {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
        }
        .color-dot {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 3px;
            border: 1px solid #999;
        }

        /* Betting Interface Styles */
        .betting-single-axis-wrapper {
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }
        .betting-single-axis-container {
            width: 90%;
            display: flex;
            align-items: center;
            gap: 15px;
        }
        .betting-hypothesis-indicator {
            font-size: 13px;
            white-space: nowrap;
        }
        .betting-single-axis {
            flex: 1;
            height: 40px;
            background: #fff;
            border: 2px solid #000;
            border-radius: 0;
            box-sizing: border-box;
        }
        .betting-loss-inline {
            font-size: 13px;
            color: #333;
        }
        .betting-row {
            display: flex;
            align-items: center;
            margin-bottom: 20px;
        }
        .betting-label {
            width: 120px;
            font-size: 14px;
            color: #333;
            flex-shrink: 0;
        }
        .betting-axis {
            background: #fff;
            border: 2px solid #000;
            border-radius: 0;
            box-sizing: border-box;
        }
        .betting-divider {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 2px;
            background: #000;
        }
        .betting-divider-label {
            position: absolute;
            bottom: -20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 11px;
            color: #333;
        }
        .betting-percent-label {
            position: absolute;
            top: -25px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 11px;
            color: #333;
            white-space: nowrap;
            z-index: 5;
        }
        .betting-odds-label {
            position: absolute;
            bottom: -25px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 11px;
            color: #666;
            white-space: nowrap;
            z-index: 5;
        }
        .betting-user-line {
            position: absolute;
            top: -5px;
            bottom: -5px;
            width: 5px;
            background: #000;
            z-index: 10;
        }
        .betting-user-label {
            position: absolute;
            top: -25px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 12px;
            font-weight: 600;
            color: #000;
            white-space: nowrap;
            background: rgba(255, 255, 255, 0.9);
            padding: 2px 4px;
            border-radius: 2px;
            z-index: 15;
        }
        .betting-truth-line {
            position: absolute;
            top: -5px;
            bottom: -5px;
            width: 5px;
            background: #000;
            z-index: 11;
        }
        .betting-truth-label {
            position: absolute;
            top: -45px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 12px;
            font-weight: 600;
            color: #000;
            white-space: nowrap;
            background: rgba(255, 255, 255, 0.9);
            padding: 2px 4px;
            border-radius: 2px;
            z-index: 16;
        }
        .betting-loss {
            margin-top: 20px;
            padding: 10px;
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="left-content">
            <div class="canvas-area">
                <canvas id="factory-canvas" width="640" height="512"></canvas>
                <div id="animation-overlay">
                    <canvas id="animation-canvas"></canvas>
                </div>
            </div>
            <div class="betting-panel">
                <div id="betting-container">
                    <!-- Betting interface will be rendered here -->
                </div>
            </div>
        </div>
        <div class="right-panel">
            <!-- Status text -->
            <div class="panel-section">
                <div id="status-text" class="status-text">Tehdas pyörii...</div>
            </div>

            <!-- Ball count -->
            <div class="panel-section">
                <div id="ball-count" class="ball-count">0 / 0</div>
            </div>

            <!-- Loss display -->
            <div class="panel-section">
                <div id="loss-display" class="loss-display"></div>
            </div>

            <!-- Speed controls -->
            <div class="panel-section">
                <div class="speed-controls">
                    <button class="speed-btn" data-speed="0" onclick="window.testApp.setSpeed(0)">0x</button>
                    <button class="speed-btn active" data-speed="1" onclick="window.testApp.setSpeed(1)">1x</button>
                    <button class="speed-btn" data-speed="3" onclick="window.testApp.setSpeed(3)">3x</button>
                    <button class="speed-btn" data-speed="9" onclick="window.testApp.setSpeed(9)">9x</button>
                </div>
            </div>

            <!-- Grid betting interface (appears below speed controls in multi-hypothesis mode) -->
            <div class="panel-section">
                <div id="hypothesis-sacks" class="hypothesis-sacks">
                    <!-- Will be populated by JavaScript -->
                </div>
            </div>

            <!-- Spacer to push button to bottom -->
            <div style="flex: 1;"></div>

            <!-- Back button -->
            <button class="takaisin-btn" onclick="window.location.href='index.html'">Takaisin</button>
        </div>
    </div>

    <!-- Level Registry -->
    <script src="levels/level-registry.js"></script>

    <!-- Configuration -->
    <script src="config/colors.js"></script>

    <!-- Core System -->
    <script src="core/rng.js"></script>
    <script src="core/trajectory.js"></script>
    <script src="core/ball.js"></script>
    <script src="core/component-registry.js"></script>
    <script src="core/simulation.js"></script>
    <script src="core/renderer.js"></script>
    <script src="core/coordinate-system.js"></script>

    <!-- Components -->
    <script src="components/sack.js"></script>
    <script src="components/conveyor.js"></script>
    <script src="components/conveyor-turn.js"></script>
    <script src="components/arm.js"></script>
    <script src="components/shuffler.js"></script>
    <script src="components/splitter.js"></script>
    <script src="components/observation.js"></script>
    <script src="components/black-pit.js"></script>
    <script src="components/duplicator.js"></script>
    <script src="components/filter.js"></script>
    <script src="components/merger.js"></script>

    <!-- Bayesian Inference -->
    <script src="bayesian/hypothesis-builder.js"></script>
    <!-- OLD VERSION (v1) - commented out, using v2 now -->
    <!-- <script src="bayesian/hypothesis-playback.js"></script> -->
    <!-- NEW VERSION (v2) - shared DSL core with immediate select fix -->
    <script src="bayesian/hypothesis-dsl-core.js"></script>
    <script src="bayesian/hypothesis-playback-v2.js"></script>
    <script src="bayesian/inference.js"></script>
    <script src="bayesian/animation-player.js"></script>
    <script src="bayesian/betting-interface.js"></script>

    <!-- Test Application -->
    <script>
    class TestApp {
      constructor() {
        this.canvas = document.getElementById('factory-canvas');
        this.level = null;
        this.simulation = null;
        this.renderer = null;
        this.animationPlayer = null;
        this.animationComplete = false;
        this.bettingInterface = null;
        this.running = false;
        this.speed = 1.0;
        this.lastTime = 0;
        this.gameStartTime = null;  // Track game start time
        this.levelId = null;  // Track current level ID

        this.loadTestLevel();
      }

      async loadTestLevel() {
        // Check URL parameters first for level ID
        const urlParams = new URLSearchParams(window.location.search);
        const levelId = urlParams.get('level');

        if (levelId) {
          // Load from localStorage
          await this.loadLevelFromRegistry(levelId);
        } else {
          // Fallback to localStorage (editor testing)
          this.loadLevelFromLocalStorage();
        }
      }

      async loadLevelFromRegistry(levelId) {
        try {
          const level = LevelRegistry.getLevel(levelId);
          if (!level) {
            alert(`Tasoa "${levelId}" ei löytynyt.`);
            return;
          }

          this.level = level;
          this.levelId = levelId;  // Store level ID for history tracking
          this.gameStartTime = Date.now();  // Start tracking time
          document.title = `${this.level.meta.title} - Bayesian Factory`;

          this.processLevelAndInit();
        } catch (error) {
          alert('Virhe tasoa ladattaessa: ' + error.message);
          console.error(error);
        }
      }

      loadLevelFromLocalStorage() {
        const levelJson = localStorage.getItem('testLevel');
        if (!levelJson) {
          alert('No level found. Please select a level or use the editor to create one.');
          return;
        }

        try {
          this.level = JSON.parse(levelJson);
          this.processLevelAndInit();
        } catch (error) {
          alert('Error loading test level: ' + error.message);
          console.error(error);
        }
      }

      processLevelAndInit() {
        try {

          // Process hypothesis script if present
          if (this.level.hypothesisScript) {
            const result = executeHypothesisScript(this.level.hypothesisScript);

            // Build mapping from export names to component IDs
            const exportNameToComponentId = new Map();
            this.level.components.forEach(comp => {
              if (comp.type === 'sack') {
                const exportName = comp.params.linkedTemplate || comp.id;
                exportNameToComponentId.set(exportName, comp.id);
              }
            });

            // Assign colors to lists and add to sack components
            const listColors = [
              '#D4A574',  // Original brown (list 0)
              '#B8E6B8',  // Light green
              '#FFD4B8',  // Light orange/peach
              '#C4B8E6',  // Light purple
              '#FFB8D4',  // Light pink
              '#B8E6E6',  // Light cyan
              '#E6E6B8',  // Light yellow
              '#E6B8C4'   // Light rose
            ];

            // Create list color map
            const listIdArray = Array.from(result.lists.keys());
            const listColorMap = new Map();
            listIdArray.forEach((listId, index) => {
              listColorMap.set(listId, listColors[index % listColors.length]);
            });

            // Add listId and color to each sack component
            result.selections.forEach((selection, exportName) => {
              const componentId = exportNameToComponentId.get(exportName);
              if (componentId) {
                const comp = this.level.components.find(c => c.id === componentId);
                if (comp) {
                  comp.params.listId = selection.listId;
                  comp.params.listColor = listColorMap.get(selection.listId);
                }
              }
            });

            // Transform hypotheses: replace export names with component IDs
            const transformedHypotheses = result.hypotheses.map(h => {
              const newAssignments = {};
              Object.entries(h.componentAssignments).forEach(([exportName, distribution]) => {
                const componentId = exportNameToComponentId.get(exportName);
                if (!componentId) {
                  throw new Error(`Export name "${exportName}" from script does not match any sack component. Available sacks: ${Array.from(exportNameToComponentId.entries()).map(([e, c]) => `${e} -> ${c}`).join(', ')}`);
                }
                newAssignments[componentId] = distribution;
              });

              return {
                id: h.id,
                componentAssignments: newAssignments,
                probability: h.probability
              };
            });

            // Map betting sack export name to component ID
            let bettingSackComponentId = null;
            if (result.bettingSack) {
              bettingSackComponentId = exportNameToComponentId.get(result.bettingSack);
              if (!bettingSackComponentId) {
                throw new Error(`Betting sack "${result.bettingSack}" does not match any sack component`);
              }
            }

            // Transform sampling schedule: replace template IDs with component IDs
            if (this.level.samplingSchedule) {
              this.level.samplingSchedule = this.level.samplingSchedule.map(entry => {
                const componentId = exportNameToComponentId.get(entry.sackId);
                if (!componentId) {
                  throw new Error(`Sampling schedule references unknown sack "${entry.sackId}". Available: ${Array.from(exportNameToComponentId.keys()).join(', ')}`);
                }
                return {sackId: componentId, time: entry.time};
              });
            }

            // Create hypothesis space from script result
            this.level.hypothesisSpace = {
              type: 'permutation',
              hypotheses: transformedHypotheses,
              sackTemplates: result.sackTemplates,
              animationInstructions: result.animationInstructions || [],
              bettingSackId: bettingSackComponentId,  // Store component ID for betting
              lists: result.lists  // Store lists to preserve template ordering
            };

            // Also store at top level for compatibility
            this.level.sackTemplates = result.sackTemplates;

          }

          // Initialize betting interface BEFORE init() so right panel has correct width
          this.initBettingInterface();

          this.init();
        } catch (error) {
          alert('Error processing level: ' + error.message);
          console.error(error);
        }
      }

      init() {
        // Calculate optimal canvas size with margins
        const bottomPanelHeight = 0; // No bottom panel (betting interface in right panel now)
        // Get actual right panel width (may have been adjusted by betting interface)
        const rightPanel = document.querySelector('.right-panel');
        const rightPanelWidth = rightPanel ? rightPanel.offsetWidth : 280;
        const margin = 30; // Board margin on all sides
        const maxWidth = window.innerWidth - rightPanelWidth - margin * 2;
        const maxHeight = window.innerHeight - bottomPanelHeight - margin * 2;

        // Grid size in cells
        const gridWidth = this.level.grid.width;
        const gridHeight = this.level.grid.height;

        // Calculate cell size to maximize game board
        const cellSize = Math.min(
          Math.floor(maxWidth / gridWidth),
          Math.floor(maxHeight / gridHeight)
        );

        this.cellSize = cellSize;
        this.animationAreaHeight = cellSize * 5; // Sufficient space for arc animations

        // Canvas size is ONLY the game board (no animation area)
        this.canvas.width = gridWidth * cellSize;
        this.canvas.height = gridHeight * cellSize;

        // Sample hypothesis and assign contents to template-linked sacks
        this.sampleAndAssignHypothesis();

        // Use random seed for each game (override any fixed seed from level)
        this.level.simulation.seed = Math.floor(Math.random() * 1000000);

        // Create simulation
        this.simulation = new Simulation(this.level, this.level.simulation);
        this.simulation.resolveReferences();

        // Mark the betting sack with a flag
        if (this.level.hypothesisSpace && this.level.hypothesisSpace.bettingSackId) {
          const bettingSackId = this.level.hypothesisSpace.bettingSackId;
          const bettingSack = this.simulation.components.find(comp => comp.id === bettingSackId);
          if (bettingSack) {
            bettingSack.params.isBettingSack = true;
          }
        }

        // Create renderer BEFORE animation player (it needs the renderer)
        this.renderer = new Renderer(this.canvas);
        this.renderer.setShowGrid(true);
        this.renderer.gridSize = cellSize; // Override default 64

        // Set up hover detection for sacks
        this.hoveredSack = null;
        this.canvas.addEventListener('mousemove', (e) => {
          const rect = this.canvas.getBoundingClientRect();
          const mouseX = e.clientX - rect.left;
          const mouseY = e.clientY - rect.top;

          // Convert to grid coordinates
          const gridX = Math.floor(mouseX / cellSize);
          const gridY = Math.floor(mouseY / cellSize);

          // Find sack at this position
          const sack = this.simulation.components.find(comp =>
            comp.type === 'sack' &&
            comp.position.x === gridX &&
            comp.position.y === gridY
          );

          this.hoveredSack = sack || null;
        });

        this.canvas.addEventListener('mouseleave', () => {
          this.hoveredSack = null;
        });

        // Hide sacks initially if we have animation (AFTER creating simulation)
        const hasAnimation = this.level.hypothesisSpace &&
                            this.level.hypothesisSpace.animationInstructions &&
                            this.level.hypothesisSpace.animationInstructions.length > 0;

        if (hasAnimation) {
          this.simulation.components.forEach(comp => {
            if (comp.type === 'sack') {
              comp.params.hidden = true;
            }
          });
        }

        // Set up animation overlay if we have animation
        if (hasAnimation) {
          const overlay = document.getElementById('animation-overlay');
          const animCanvas = document.getElementById('animation-canvas');

          // Create coordinate system with fixed pixel inset (max 30px)
          // For small cells, use 0.5 cells; for large cells, cap at 30px
          const overlayInsetCells = Math.min(0.5, 30 / cellSize);
          const coords = new CoordinateSystem(
            cellSize,
            this.canvas.width,
            this.canvas.height,
            overlayInsetCells
          );

          // Get overlay dimensions from coordinate system
          const overlayDims = coords.getOverlayDimensions();
          animCanvas.width = overlayDims.width;
          animCanvas.height = overlayDims.height;

          // Position overlay relative to actual board canvas position
          const boardRect = this.canvas.getBoundingClientRect();
          const margin = coords.overlayInsetPixels;


          overlay.style.left = `${boardRect.left + margin}px`;
          overlay.style.top = `${boardRect.top + margin}px`;
          overlay.style.width = `${overlayDims.width}px`;
          overlay.style.height = `${overlayDims.height}px`;

          const instructions = this.level.hypothesisSpace.animationInstructions;
          this.animationPlayer = new AnimationPlayer(
            animCanvas,
            instructions,
            this.level,
            this.animationAreaHeight,
            cellSize,
            this.renderer,
            this.simulation,
            coords  // Pass coordinate system
          );
          this.animationPlayer.onComplete = () => {
            this.animationComplete = true;
            // Hide overlay
            overlay.style.display = 'none';
            // Show sacks on game board now
            this.simulation.components.forEach(comp => {
              if (comp.type === 'sack') {
                comp.params.hidden = false;
              }
            });
          };

          // Show overlay when animation starts
          overlay.style.display = 'flex';
        } else {
          this.animationComplete = true;
        }

        // Render initial state
        this.renderFrame(0);

        // Initialize right panel (betting interface already initialized before init())
        this.initRightPanel();


        // Auto-play the game
        this.play();
      }

      initBettingInterface() {
        const bottomContainer = document.getElementById('betting-container');
        const rightPanelContainer = document.getElementById('hypothesis-sacks');
        const hypothesisSpace = this.level.hypothesisSpace;

        // Hide bottom panel entirely (always use right panel now)
        bottomContainer.style.display = 'none';

        if (!hypothesisSpace || !hypothesisSpace.bettingSackId) {
          rightPanelContainer.innerHTML = '<div style="padding: 10px; color: #666; font-size: 14px;">No betting sack designated. Use <code>.forBetting()</code> in hypothesis script to enable betting.</div>';
          return;
        }

        // Get star thresholds from level metadata (default: [0.01, 0.05, 0.1, 0.2])
        const starThresholds = this.level.meta?.bettingConfig?.starThresholds || [0.01, 0.05, 0.1, 0.2];

        // Get possible distributions for the betting sack
        const bettingSackId = hypothesisSpace.bettingSackId;
        const distributions = new Set();

        hypothesisSpace.hypotheses.forEach(h => {
          const dist = h.componentAssignments[bettingSackId];
          if (dist) {
            distributions.add(JSON.stringify(dist));
          }
        });

        // Create distribution array with equal priors
        const distArray = Array.from(distributions).map(distKey => ({
          dist: JSON.parse(distKey),
          prob: 1.0 / distributions.size
        }));


        // Always use right panel for grid interface
        const container = rightPanelContainer;
        const rightPanel = document.querySelector('.right-panel');

        // Adjust right panel width based on number of hypotheses
        const numHypotheses = distArray.length;
        const cellWidth = 80;
        const labelWidth = 50; // Percentage labels on left
        const gridWidth = numHypotheses * cellWidth + labelWidth;
        const minPanelWidth = Math.max(280, gridWidth + 40); // Add padding
        rightPanel.style.width = `${minPanelWidth}px`;


        // Create betting interface
        this.bettingInterface = new BettingInterface(container, {
          sackId: bettingSackId,
          distributions: distArray,
          starThresholds: starThresholds
        });

        // Set up callback for when betting is complete
        this.bettingInterface.onComplete = () => {
          this.onBettingComplete();
        };
      }

      onBettingComplete() {

        // Get posteriors from Bayesian tracker
        if (this.simulation && this.simulation.bayesianTracker) {
          const sackPosteriors = this.simulation.bayesianTracker.getSackPosteriors();
          const bettingSackId = this.level.hypothesisSpace.bettingSackId;
          const posteriors = sackPosteriors.get(bettingSackId);

          if (posteriors) {
            const result = this.bettingInterface.showResults(posteriors);

            // Display stars in right panel
            const lossDisplay = document.getElementById('loss-display');
            if (lossDisplay) {
              const starDisplay = this.bettingInterface.getStarDisplay(result.stars);
              lossDisplay.textContent = starDisplay;
              lossDisplay.style.display = 'block';
            }

            // Save history entry (only if loaded from registry with level ID)
            if (this.levelId && this.gameStartTime) {
              this.saveHistoryEntry(posteriors, result);
            }
          }
        }
      }

      saveHistoryEntry(correctPosteriors, result) {
        const duration = (Date.now() - this.gameStartTime) / 1000;  // seconds

        // Extract player assignments from betting interface
        const playerAssignments = {};
        this.bettingInterface.gridSelections.forEach((selection, colIndex) => {
          const distKey = JSON.stringify(this.bettingInterface.distributions[colIndex].dist);
          playerAssignments[distKey] = selection.probability;
        });

        // Extract correct posteriors
        const correctPosteriorsObj = {};
        correctPosteriors.forEach((prob, distKey) => {
          correctPosteriorsObj[distKey] = prob;
        });

        // Create history entry
        const historyEntry = {
          timestamp: new Date().toISOString(),
          duration: duration,
          playerAssignments: playerAssignments,
          correctPosteriors: correctPosteriorsObj,
          klDivergence: result.loss,  // KL divergence is stored as 'loss'
          stars: result.stars
        };

        // Save to registry
        LevelRegistry.addHistoryEntry(this.levelId, historyEntry);

        console.log('History saved:', historyEntry);
      }

      initRightPanel() {
        // No longer populate visual sacks (using hover popups instead)

        // Initialize ball count
        const totalBalls = this.level.simulation?.ballsToSpawn || 0;
        this.updateBallCount(0, totalBalls);

        // Initialize status
        this.updateStatus('running');
      }

      renderSackOnCanvas(canvas, distribution, sackWidth, sackHeight) {
        const ctx = canvas.getContext('2d');
        const x = 5;
        const y = 5;

        // Draw U-shaped sack (same code as AnimationPlayer)
        ctx.fillStyle = "#D4A574";
        ctx.strokeStyle = "#8B6F47";
        ctx.lineWidth = 2;
        ctx.lineCap = "round";
        ctx.lineJoin = "round";

        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x, y + sackHeight);
        ctx.lineTo(x + sackWidth, y + sackHeight);
        ctx.lineTo(x + sackWidth, y);
        ctx.stroke();
        ctx.fill();

        // Draw distribution label inside sack
        const colors = Object.keys(distribution).sort();
        const fontSize = 12;
        ctx.font = `${fontSize}px sans-serif`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";

        // Position label in middle of sack
        const centerX = x + sackWidth / 2;
        const centerY = y + sackHeight / 2;

        // Draw each color with ball and count
        let offsetY = centerY - (colors.length - 1) * 10;
        colors.forEach(color => {
          const count = distribution[color];

          // Draw colored ball
          ctx.fillStyle = color;
          ctx.strokeStyle = "rgba(0,0,0,0.3)";
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.arc(centerX - 15, offsetY, 6, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();

          // Draw count
          ctx.fillStyle = "#000";
          ctx.fillText(count.toString(), centerX + 5, offsetY);

          offsetY += 20;
        });
      }

      formatDistribution(dist) {
        const colors = Object.keys(dist).sort();
        return colors.map(color => {
          const count = dist[color];
          return `<span class="color-dot" style="background-color: ${color}"></span> ${count}`;
        }).join(' ');
      }

      setSpeed(speed) {
        if (speed === 0) {
          // Pause
          this.pause();
        } else {
          // Set speed
          this.speed = speed;

          // Resume if currently paused and game hasn't completed
          // (betting is only enabled when game completes)
          const gameComplete = this.bettingInterface && this.bettingInterface.enabled;
          if (!this.running && !gameComplete) {
            this.play();
          }
        }

        // Update button states
        document.querySelectorAll('.speed-btn').forEach(btn => {
          const btnSpeed = parseInt(btn.getAttribute('data-speed'));
          if (btnSpeed === speed) {
            btn.classList.add('active');
          } else {
            btn.classList.remove('active');
          }
        });
      }

      updateStatus(state) {
        const statusText = document.getElementById('status-text');
        if (!statusText) return;

        switch (state) {
          case 'running':
            statusText.textContent = 'Tehdas pyörii...';
            statusText.style.color = '#666';
            break;
          case 'paused':
            statusText.textContent = 'Pysäytetty';
            statusText.style.color = '#e67e22';
            break;
          case 'complete':
            statusText.textContent = 'Valmis';
            statusText.style.color = '#27ae60';
            break;
        }
      }

      updateBallCount(current, total) {
        const ballCount = document.getElementById('ball-count');
        if (ballCount) {
          ballCount.textContent = `${current} / ${total}`;
        }
      }

      sampleAndAssignHypothesis() {
        // Check if we have a hypothesis space with generated hypotheses
        if (!this.level.hypothesisSpace || !this.level.hypothesisSpace.hypotheses) {
          return;
        }

        const hypotheses = this.level.hypothesisSpace.hypotheses;
        if (hypotheses.length === 0) {
          return;
        }

        // Sample one hypothesis uniformly at random
        const sampledHypothesis = hypotheses[Math.floor(Math.random() * hypotheses.length)];

        // Assign contents to all sacks based on sampled hypothesis
        // Note: hypotheses use component IDs as keys (transformed in loadTestLevel)
        this.level.components.forEach(comp => {
          if (comp.type === 'sack') {
            if (!sampledHypothesis.componentAssignments) {
              throw new Error(`Sampled hypothesis has no componentAssignments`);
            }

            // Get distribution from sampled hypothesis using component ID
            const distribution = sampledHypothesis.componentAssignments[comp.id];

            if (!distribution) {
              throw new Error(`Sack ${comp.id} not found in hypothesis. Available: ${Object.keys(sampledHypothesis.componentAssignments).join(', ')}`);
            }

            comp.params.contents = distribution;
          }
        });
      }

      togglePlay() {
        if (this.running) {
          this.pause();
        } else {
          this.play();
        }
      }

      play() {
        this.running = true;
        this.lastTime = performance.now();

        // Start animation if not complete
        if (this.animationPlayer && !this.animationComplete) {
          this.animationPlayer.start();
        }

        this.updateStatus('running');
        this.loop();
      }

      pause() {
        this.running = false;
        this.updateStatus('paused');
      }

      reset() {
        this.pause();

        // Resample a new hypothesis with random seed
        this.simulation.config.seed = Math.floor(Math.random() * 1000000);
        this.sampleAndAssignHypothesis();

        this.simulation.reset();
        this.animationComplete = false;

        // Hide sacks again if we have animation
        const hasAnimation = this.animationPlayer !== null;
        if (hasAnimation) {
          this.simulation.components.forEach(comp => {
            if (comp.type === 'sack') {
              comp.params.hidden = true;
            }
          });

          // Show overlay and recreate animation player
          const overlay = document.getElementById('animation-overlay');
          const animCanvas = document.getElementById('animation-canvas');
          overlay.style.display = 'flex';

          // Recreate coordinate system with fixed pixel inset (max 30px)
          const overlayInsetCells = Math.min(0.5, 30 / this.cellSize);
          const coords = new CoordinateSystem(
            this.cellSize,
            this.canvas.width,
            this.canvas.height,
            overlayInsetCells
          );

          this.animationPlayer = new AnimationPlayer(
            animCanvas, // Use overlay canvas
            this.level.hypothesisSpace.animationInstructions,
            this.level,
            this.animationAreaHeight,
            this.cellSize,
            this.renderer,
            this.simulation,
            coords
          );
          this.animationPlayer.onComplete = () => {
            this.animationComplete = true;
            // Hide overlay
            overlay.style.display = 'none';
            // Show sacks on game board now
            this.simulation.components.forEach(comp => {
              if (comp.type === 'sack') {
                comp.params.hidden = false;
              }
            });
          };
        } else {
          this.animationComplete = true;
        }
        this.renderFrame(0);

        // Reset betting interface
        if (this.bettingInterface) {
          this.bettingInterface.reset();
        }
      }

      cycleSpeed() {
        const speeds = [0.5, 1.0, 2.0, 4.0];
        const currentIndex = speeds.indexOf(this.speed);
        this.speed = speeds[(currentIndex + 1) % speeds.length];
      }

      loop() {
        const currentTime = performance.now();
        const deltaTime = this.running ? (currentTime - this.lastTime) * this.speed : 0;
        this.lastTime = currentTime;

        // State 1: Playing animation
        if (!this.animationComplete && this.animationPlayer && this.running) {
          this.animationPlayer.update(deltaTime);
          this.animationPlayer.render(); // Render animation to overlay canvas
          this.renderFrame(0); // Render board underneath
        }
        // State 2: Normal gameplay
        else {
          if (this.running) {
            const wasRunning = this.simulation.running;
            this.simulation.tick(deltaTime);

            // Update ball count
            if (this.simulation) {
              const totalBalls = this.level.simulation?.ballsToSpawn || 0;
              const spawnedBalls = this.simulation.spawnedBalls || 0;
              this.updateBallCount(spawnedBalls, totalBalls);
            }

            // Check if simulation just completed
            if (wasRunning && !this.simulation.running) {
              this.updateStatus('complete');
              if (this.bettingInterface) {
                this.bettingInterface.enable();
              }
              this.pause(); // Stop playback so user can place bets
            }
          }

          // Always render, even when paused (for hover popups to work)
          this.renderFrame(this.simulation.getTime());
        }

        requestAnimationFrame(() => this.loop());
      }

      renderFrame(simTime) {
        const ctx = this.canvas.getContext('2d');

        // Clear canvas with white background
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        // Light background for game board area
        ctx.fillStyle = '#f5f5f5';
        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        // Render game board (no transforms needed!)
        this.renderer.render(this.simulation, simTime);

        // Render hover popup if hovering over a sack
        if (this.hoveredSack) {
          this.renderHoverPopup(ctx);
        }
      }

      /**
       * Render popup showing all possible distributions for the hovered sack
       */
      renderHoverPopup(ctx) {
        if (!this.hoveredSack || !this.level.hypothesisSpace) return;

        const sackId = this.hoveredSack.id;
        const hypotheses = this.level.hypothesisSpace.hypotheses;

        // Get all unique distributions for this sack
        const distributions = new Map(); // distribution JSON -> distribution object
        hypotheses.forEach(h => {
          const dist = h.componentAssignments[sackId];
          if (dist) {
            const key = JSON.stringify(dist);
            distributions.set(key, dist);
          }
        });

        // Sort distributions in the same order as defined in the DSL script
        let uniqueDistributions = Array.from(distributions.values());

        // If we have list information and this sack has a listId, use the original template order
        if (this.level.hypothesisSpace.lists && this.hoveredSack.params.listId) {
          const listId = this.hoveredSack.params.listId;
          const listInfo = this.level.hypothesisSpace.lists.get(listId);

          if (listInfo && listInfo.templates) {
            // Sort by index in original templates array
            uniqueDistributions.sort((a, b) => {
              const indexA = listInfo.templates.findIndex(t => JSON.stringify(t) === JSON.stringify(a));
              const indexB = listInfo.templates.findIndex(t => JSON.stringify(t) === JSON.stringify(b));
              return indexA - indexB;
            });
          }
        }

        if (uniqueDistributions.length === 0) return;

        // Grid layout: 4 sacks per row
        const sacksPerRow = 4;
        const sackWidth = 55;
        const sackHeight = 70;
        const sackPadding = 10;
        const sackCellWidth = sackWidth + sackPadding * 2;
        const sackCellHeight = sackHeight + sackPadding * 2;

        const numRows = Math.ceil(uniqueDistributions.length / sacksPerRow);
        const popupPadding = 10;

        // Popup dimensions
        const popupWidth = sacksPerRow * sackCellWidth + popupPadding * 2;
        const popupHeight = numRows * sackCellHeight + popupPadding * 2;
        const popupX = 20;
        const popupY = 20;

        // Draw popup background
        ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 2;
        ctx.fillRect(popupX, popupY, popupWidth, popupHeight);
        ctx.strokeRect(popupX, popupY, popupWidth, popupHeight);

        // Draw each possible distribution in grid layout
        uniqueDistributions.forEach((dist, index) => {
          const row = Math.floor(index / sacksPerRow);
          const col = index % sacksPerRow;

          // Draw mini sack visualization
          const sackX = popupX + popupPadding + col * sackCellWidth + sackPadding;
          const sackY = popupY + popupPadding + row * sackCellHeight + sackPadding;

          // Use the sack's list color
          const fillColor = this.hoveredSack.params.listColor || '#D4A574';
          ctx.fillStyle = fillColor;
          ctx.strokeStyle = this.darkenColor(fillColor);
          ctx.lineWidth = 2;

          // Draw U-shaped sack
          ctx.beginPath();
          ctx.moveTo(sackX, sackY);
          ctx.lineTo(sackX, sackY + sackHeight);
          ctx.lineTo(sackX + sackWidth, sackY + sackHeight);
          ctx.lineTo(sackX + sackWidth, sackY);
          ctx.stroke();
          ctx.fill();

          // Draw distribution inside sack (match animation style)
          const colors = Object.keys(dist);
          const contentY = sackY + sackHeight * 0.3;
          const lineHeight = 15; // Vertical spacing between ball rows
          const ballRadius = 6;
          const circleX = sackX + sackWidth * 0.2;

          ctx.font = '12px sans-serif';
          ctx.textAlign = 'left';
          ctx.textBaseline = 'middle';

          colors.forEach((color, idx) => {
            const count = dist[color];
            const labelY = contentY + idx * lineHeight;

            // Draw colored ball
            ctx.fillStyle = this.getBallColor(color);
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(circleX, labelY, ballRadius, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();

            // Draw count text
            ctx.fillStyle = '#000';
            ctx.fillText(`×${count}`, circleX + ballRadius * 2, labelY);
          });
        });
      }

      /**
       * Darken a hex color by multiplying RGB values by 0.7
       */
      darkenColor(hex) {
        const r = parseInt(hex.slice(1, 3), 16);
        const g = parseInt(hex.slice(3, 5), 16);
        const b = parseInt(hex.slice(5, 7), 16);

        const newR = Math.round(r * 0.7);
        const newG = Math.round(g * 0.7);
        const newB = Math.round(b * 0.7);

        return `#${newR.toString(16).padStart(2, '0')}${newG.toString(16).padStart(2, '0')}${newB.toString(16).padStart(2, '0')}`;
      }

      /**
       * Get ball color hex code
       */
      getBallColor(colorName) {
        const colors = {
          red: '#E53935',
          blue: '#1E88E5',
          green: '#43A047',
          yellow: '#FDD835',
          purple: '#8E24AA',
          black: '#212121'
        };
        return colors[colorName] || '#888888';
      }

      easeInOutCubic(t) {
        return t < 0.5
          ? 4 * t * t * t
          : 1 - Math.pow(-2 * t + 2, 3) / 2;
      }
    }

    window.addEventListener('DOMContentLoaded', () => {
      const app = new TestApp();
      window.testApp = app;
    });
    </script>
</body>
</html>
