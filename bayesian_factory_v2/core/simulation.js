/**
 * Simulation Engine
 *
 * Tick-based simulation of ball flow through factory
 */

class Simulation {
  constructor(level, config) {
    this.level = level;
    this.config = config || {
      ballProductionInterval: 5000,
      ballSpeed: 1.0,
      ballsToSpawn: 20,
      seed: 42
    };

    // Time
    this.time = 0;
    this.nextBallProductionTime = this.config.ballProductionInterval;
    this.ballsProduced = 0;

    // Running state
    this.running = true;

    // Components
    this.components = this.initializeComponents(level);
    this.componentsById = new Map();
    this.components.forEach(c => this.componentsById.set(c.id, c));

    // Balls
    this.balls = [];
    this.nextBallId = 0;

    // RNG
    this.rng = new RNG(this.config.seed);

    // Find arms for ball production
    this.arms = this.components.filter(c => c.type === "arm");

    // Sampling schedule (if specified)
    this.samplingSchedule = level.samplingSchedule || null;
    // Sort schedule by time to ensure correct processing order
    if (this.samplingSchedule) {
      this.samplingSchedule.sort((a, b) => a.time - b.time);
    }
    this.scheduleIndex = 0;

    // Bayesian inference tracker
    this.bayesianTracker = this.initializeBayesianTracker(level);

    // Callbacks
    this.onObservation = null;
  }

  /**
   * Initialize components from level definition
   */
  initializeComponents(level) {
    return level.components.map(compDef => {
      const component = {
        id: compDef.id,
        type: compDef.type,
        position: {...compDef.position},
        params: {...compDef.params},
        bufferState: null,
        observedBalls: [],
        observations: [],
        onObservation: null,
        simulation: this  // Reference to simulation for Bayesian tracker access
      };

      // Resolve references (assignedSack, outputConveyor)
      if (compDef.params.assignedSackId) {
        // Will be resolved after all components created
        component.assignedSackRef = compDef.params.assignedSackId;
      }
      if (compDef.params.outputConveyorId) {
        component.outputConveyorRef = compDef.params.outputConveyorId;
      }

      return component;
    });
  }

  /**
   * Resolve component references
   */
  resolveReferences() {
    this.components.forEach(comp => {
      if (comp.assignedSackRef) {
        comp.assignedSack = this.componentsById.get(comp.assignedSackRef);
        if (!comp.assignedSack) {
          console.warn(`Sack ${comp.assignedSackRef} not found for ${comp.id}`);
        }
      }
      if (comp.outputConveyorRef) {
        comp.outputConveyor = this.componentsById.get(comp.outputConveyorRef);
        if (!comp.outputConveyor) {
          console.warn(`Conveyor ${comp.outputConveyorRef} not found for ${comp.id}`);
        }
      }
    });
  }

  /**
   * Initialize Bayesian tracker for hypothesis updating
   */
  initializeBayesianTracker(level) {
    // Check if we have a hypothesis space
    if (!level.hypothesisSpace) {
      return null;
    }

    // Find all sacks on the board (these are the positions we're uncertain about)
    const sacks = this.components.filter(c => c.type === 'sack');
    if (sacks.length === 0) {
      return null;
    }

    // Require permutation-based format with pre-generated hypotheses
    if (level.hypothesisSpace.type !== 'permutation' || !level.hypothesisSpace.hypotheses) {
      console.error('Invalid hypothesis space format. Expected type="permutation" with pre-generated hypotheses.');
      return null;
    }

    if (level.hypothesisSpace.hypotheses.length === 0) {
      console.error('Empty hypothesis space - no hypotheses generated by level editor');
      return null;
    }

    // Convert from level editor format to BayesianTracker format
    const colors = new Set();
    const hypotheses = level.hypothesisSpace.hypotheses.map(h => {
      const sackAssignments = new Map();

      // Convert componentAssignments (plain object) to sackAssignments (Map)
      if (h.componentAssignments) {
        Object.entries(h.componentAssignments).forEach(([sackId, distribution]) => {
          sackAssignments.set(sackId, distribution);

          // Extract colors
          Object.keys(distribution).forEach(color => colors.add(color));
        });
      }

      return {
        id: h.id,
        sackAssignments: sackAssignments
      };
    });

    // Create tracker
    if (typeof BayesianTracker === 'undefined') {
      console.error('BayesianTracker class not loaded!');
      return null;
    }

    return new BayesianTracker(hypotheses, Array.from(colors));
  }

  /**
   * Generate all hypotheses (ordered selections of distributions for sack positions)
   */
  generateHypotheses(sacks, distributions) {
    const hypotheses = [];
    let nextId = 0;

    // Generate all ordered selections (permutations with repetition allowed)
    const generate = (sackIndex, currentAssignment) => {
      if (sackIndex === sacks.length) {
        // Complete hypothesis
        const sackAssignments = new Map();
        sacks.forEach((sack, i) => {
          sackAssignments.set(sack.id, currentAssignment[i]);
        });

        hypotheses.push({
          id: `h${nextId++}`,
          sackAssignments: sackAssignments
        });
        return;
      }

      // Try each distribution for this sack position
      for (const dist of distributions) {
        generate(sackIndex + 1, [...currentAssignment, dist]);
      }
    };

    generate(0, []);
    return hypotheses;
  }

  /**
   * Main simulation tick
   */
  tick(deltaTime) {
    this.time += deltaTime;

    // 1. Ball production - using sampling schedule
    if (!this.samplingSchedule) {
      throw new Error('Sampling schedule is required but not specified in level');
    }

    while (this.scheduleIndex < this.samplingSchedule.length) {
      const scheduleEntry = this.samplingSchedule[this.scheduleIndex];
      const TIME_UNIT = 2000; // Each time unit = 2.5 seconds (one full arm cycle)
      const scheduledTime = scheduleEntry.time * TIME_UNIT;

      if (this.time >= scheduledTime) {
        this.produceBallFromSack(scheduleEntry.sackId);
        this.scheduleIndex++;
      } else {
        break; // Wait for next scheduled time
      }
    }

    // 2. Check arms for placing balls
    this.arms.forEach(arm => {
      const armSpec = ComponentRegistry.get("arm");
      if (armSpec.checkAndPlace) {
        armSpec.checkAndPlace(arm, this.time, armSpec);
      }
    });

    // 2b. Check shufflers for outputting balls
    this.components.forEach(comp => {
      if (comp.type === 'shuffler') {
        const shufflerSpec = ComponentRegistry.get("shuffler");
        if (shufflerSpec.checkAndOutput) {
          shufflerSpec.checkAndOutput(comp, this.time, shufflerSpec);
        }
      }
    });

    // 2c. Check duplicators for outputting balls
    this.components.forEach(comp => {
      if (comp.type === 'duplicator') {
        const duplicatorSpec = ComponentRegistry.get("duplicator");
        if (duplicatorSpec.transitions.checkAndOutput) {
          duplicatorSpec.transitions.checkAndOutput(comp, this.time, duplicatorSpec);
        }
      }
    });

    // 2d. Check filters for outputting balls
    this.components.forEach(comp => {
      if (comp.type === 'filter') {
        const filterSpec = ComponentRegistry.get("filter");
        if (filterSpec.transitions.checkAndOutput) {
          filterSpec.transitions.checkAndOutput(comp, this.time, filterSpec);
        }
      }
    });

    // 3. Check components for transfers
    this.components.forEach(comp => {
      if (comp.needsTransfer && comp.ballToTransfer) {
        this.transferBall(comp.ballToTransfer, comp);
        comp.needsTransfer = false;
        comp.ballToTransfer = null;
      }
    });

    // 4. Check trajectory completions
    const completedBalls = this.balls.filter(ball =>
      ball.isTrajectoryComplete(this.time)
    );

    completedBalls.forEach(ball => {
      this.handleTrajectoryComplete(ball);
    });

    // 5. Check if simulation is complete
    if (this.running) {
      const allBallsSpawned = this.ballsProduced >= this.config.ballsToSpawn;

      // Check if all balls have been collected (reached observation point, consumed by Black Pit, or faded away)
      // Note: Need to check balls exist and all are observed or consumed
      const allBallsCollected = this.balls.length > 0 && this.balls.every(ball =>
        ball.componentState === 'observed' || ball.componentState === 'consumed'
      );

      if (allBallsSpawned && allBallsCollected) {
        this.running = false;
      }
    }
  }

  /**
   * Produce ball from a specific sack (used by sampling schedule)
   */
  produceBallFromSack(sackId) {
    // Find sack by ID
    const sack = this.componentsById.get(sackId);
    if (!sack || sack.type !== 'sack') {
      throw new Error(`Invalid sack ID in sampling schedule: ${sackId}`);
    }

    // Find arm connected to this sack
    const arm = this.arms.find(a => a.assignedSack && a.assignedSack.id === sackId);
    if (!arm) {
      throw new Error(`No arm found for sack ${sackId} in sampling schedule`);
    }

    const sackSpec = ComponentRegistry.get("sack");

    // Draw ball color from sack
    const color = sackSpec.behavior.draw(this.rng, sack.params);

    // Create ball
    const ball = new Ball(`ball_${this.nextBallId++}`, color);
    ball.sourceId = sack.id;
    this.balls.push(ball);
    this.ballsProduced++;

    // Notify Bayesian tracker of ball spawn
    if (this.bayesianTracker) {
      // Convert sack.id to string to match componentAssignments keys
      this.bayesianTracker.onBallSpawned(ball.id, String(sack.id));
    }

    // Start arm pickup sequence
    const armSpec = ComponentRegistry.get("arm");
    armSpec.transitions.onPickup(ball, arm, this.time, armSpec);

  }

  /**
   * Produce new ball via arm (DEPRECATED - use sampling schedule instead)
   */
  produceBall() {
    throw new Error('produceBall() called but sampling schedule should be used instead');
  }

  /**
   * Create a new ball mid-simulation (used by duplicator)
   * Does NOT call onBallSpawned - caller should use onBallDuplicated instead
   *
   * @param {string} color - Ball color
   * @param {string} sourceId - Original source sack ID
   * @returns {Ball} - The created ball
   */
  createBall(color, sourceId) {
    const ball = new Ball(`ball_${this.nextBallId++}`, color);
    ball.sourceId = sourceId;
    this.balls.push(ball);
    return ball;
  }

  /**
   * Handle trajectory completion
   */
  handleTrajectoryComplete(ball) {
    const component = this.componentsById.get(ball.componentId);
    if (!component) {
      console.error(`Component ${ball.componentId} not found for ball ${ball.id}`);
      return;
    }

    const spec = ComponentRegistry.get(component.type);

    if (spec.transitions.onTrajectoryComplete) {
      // Let component handle its own trajectory completion
      spec.transitions.onTrajectoryComplete(ball, component, this.time, spec);
    } else {
      // Default: transfer to next component
      this.transferBall(ball, component);
    }
  }

  /**
   * Transfer ball to next component
   */
  transferBall(ball, fromComponent) {
    // For components with multiple outputs, find the correct connection
    let connection;

    // Shufflers and duplicators use ball.outputSide (cardinal directions)
    if ((fromComponent.type === 'shuffler' || fromComponent.type === 'duplicator') && ball.outputSide) {
      const allConnections = this.level.connections.filter(c => c.from === fromComponent.id);
      const outputSide = ball.outputSide;


      // Find connection based on cardinal direction
      connection = allConnections.find(conn => {
        const target = this.componentsById.get(conn.to);
        if (!target) return false;

        let matches = false;
        switch (outputSide) {
          case 'up':
            matches = target.position.y < fromComponent.position.y;
            break;
          case 'down':
            matches = target.position.y > fromComponent.position.y;
            break;
          case 'left':
            matches = target.position.x < fromComponent.position.x;
            break;
          case 'right':
            matches = target.position.x > fromComponent.position.x;
            break;
        }

        return matches;
      });


      // Clear the ball's output side
      delete ball.outputSide;
    }
    // Splitters and filters use fromComponent.outputSide (relative: left/right)
    else if ((fromComponent.type === 'splitter' || fromComponent.type === 'filter') && fromComponent.outputSide) {
      // Find the connection for the specific output side
      const allConnections = this.level.connections.filter(c => c.from === fromComponent.id);

      // Determine which connection based on outputSide and direction
      const direction = fromComponent.params.direction || (fromComponent.type === 'splitter' ? 'right' : 'down');
      const outputSide = fromComponent.outputSide;


      connection = allConnections.find(conn => {
        const target = this.componentsById.get(conn.to);
        if (!target) return false;


        // Direction-aware output matching
        let matches = false;
        switch (direction) {
          case 'right':
            // Left output = up, Right output = down
            matches = outputSide === 'left'
              ? target.position.y < fromComponent.position.y
              : target.position.y > fromComponent.position.y;
            break;
          case 'down':
            // Left output = left, Right output = right
            matches = outputSide === 'left'
              ? target.position.x < fromComponent.position.x
              : target.position.x > fromComponent.position.x;
            break;
          case 'left':
            // Left output = down, Right output = up
            matches = outputSide === 'left'
              ? target.position.y > fromComponent.position.y
              : target.position.y < fromComponent.position.y;
            break;
          case 'up':
            // Left output = right, Right output = left
            matches = outputSide === 'left'
              ? target.position.x > fromComponent.position.x
              : target.position.x < fromComponent.position.x;
            break;
        }

        return matches;
      });


      // Clear the output side flag
      fromComponent.outputSide = null;
    } else {
      // Normal single output
      const allFromConnections = this.level.connections.filter(c => c.from === fromComponent.id);

      if (allFromConnections.length > 1) {
        console.error(`ERROR: Component ${fromComponent.id} (${fromComponent.type}) has ${allFromConnections.length} outgoing connections!`, allFromConnections);
        console.error('Component position:', fromComponent.position);
        console.error('All connections:', this.level.connections);
      }

      connection = allFromConnections[0];
    }

    if (!connection) {
      console.warn(`No connection from ${fromComponent.id}, ball ${ball.id} reaching end`);
      return;
    }

    const nextComponent = this.componentsById.get(connection.to);
    if (!nextComponent) {
      console.error(`Next component ${connection.to} not found`);
      return;
    }

    // Detect potential cycles
    if (ball.lastTenComponents) {
      ball.lastTenComponents.push(nextComponent.id);
      if (ball.lastTenComponents.length > 10) {
        ball.lastTenComponents.shift();
      }

      // Check if we're in a tight loop
      const uniqueComponents = new Set(ball.lastTenComponents);
      if (uniqueComponents.size <= 3 && ball.lastTenComponents.length === 10) {
        console.error(`WARNING: Ball ${ball.id} appears to be in a loop! Last 10 components:`, ball.lastTenComponents);
        console.error('Current connection:', connection);
        console.error('From component:', fromComponent.id, fromComponent.position);
        console.error('To component:', nextComponent.id, nextComponent.position);
      }
    } else {
      ball.lastTenComponents = [nextComponent.id];
    }

    const nextSpec = ComponentRegistry.get(nextComponent.type);

    // Compute input direction
    ball.inputDirection = computeInputDirection(fromComponent, nextComponent);

    // Transfer ownership
    if (nextSpec.transitions.onArrival) {
      nextSpec.transitions.onArrival(ball, nextComponent, this.time, nextSpec);
    }

  }

  /**
   * Get component by ID
   */
  getComponent(id) {
    return this.componentsById.get(id);
  }

  /**
   * Get all balls
   */
  getBalls() {
    return this.balls;
  }

  /**
   * Get current time
   */
  getTime() {
    return this.time;
  }

  /**
   * Get number of balls spawned so far
   */
  get spawnedBalls() {
    return this.ballsProduced;
  }

  /**
   * Reset simulation
   */
  reset() {
    this.time = 0;
    this.nextBallProductionTime = this.config.ballProductionInterval;
    this.ballsProduced = 0;
    this.scheduleIndex = 0;  // Reset schedule position
    this.running = true;
    this.balls = [];
    this.nextBallId = 0;
    this.rng = new RNG(this.config.seed);

    // Reset component states
    this.components.forEach(comp => {
      comp.bufferState = null;
      comp.observedBalls = [];
      comp.observations = [];
    });

    // Reset Bayesian tracker to uniform prior
    if (this.bayesianTracker) {
      this.bayesianTracker.reset();
    }
  }
}

/**
 * Helper method for components to transfer balls
 */
if (typeof window !== 'undefined') {
  window.transferBallHelper = function(component, ball, simulation) {
    simulation.transferBall(ball, component);
  };
}
